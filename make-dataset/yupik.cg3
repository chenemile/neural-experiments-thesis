DELIMITERS = "<.>" "<!>" "<¶>" "<...>" "<?>" "<\;>" "<:>" "<-->" "<$>" "$."  ; # context window
MAPPING-PREFIX = @ ;

SETS
LIST BOS = (>>>) ;
LIST EOS = (<<<) ;
LIST PUNCT = [PUNCT] ;
LIST MORPHEME = \^ ; # morpheme boundary
LIST QUESTION = "<?>" ;
LIST CLB = "<,>" '\"' ; # clause boundaries

################################
# morphological tags for nouns #
################################

LIST NOUN = \(N\) ; # noun root

LIST N_N = \(N→N\) ; # noun-elaborating postbase
LIST N_V = \(N→V\) ; # verbalizing postbase

#------#
# Case #
#------#

LIST ABS = [Abs] ; # absolutive case
LIST REL = [Rel] ; # relative case

LIST ABL_MOD = [Abl_Mod] ; # ablative-modalis case
LIST LOC = [Loc] ; # locative (localis) case
LIST ALL = [All] ; # allative (terminalis) case
LIST PRL = [Prl] ; # perlative (vialis) case
LIST EQU = [Equ] ; # equative (equalis) case

SET SYNTACTIC_CASE = ABS | REL ;
SET OBLIQUE_CASE = ABL_MOD | LOC | ALL | PRL | EQU ;

#-----------#
# Possessor #
#-----------#

LIST 1SG_POSS = [1SgPoss] ; # 1st person singular possessor
LIST 1DU_POSS = [1DuPoss] ; # 1st person dual possessor
LIST 1PL_POSS = [1PlPoss] ; # 1st person plural possessor

LIST 2SG_POSS = [2SgPoss] ; # 2nd person singular possessor
LIST 2DU_POSS = [2DuPoss] ; # 2nd person dual possessor
LIST 2PL_POSS = [2PlPoss] ; # 2nd person plural possessor

LIST 3SG_POSS = [3SgPoss] ; # 3rd person singular possessor
LIST 3DU_POSS = [3DuPoss] ; # 3rd person dual possessor
LIST 3PL_POSS = [3PlPoss] ; # 3rd person plural possessor

LIST 4SG_POSS = [4SgPoss] ; # 4th person singular possessor
LIST 4DU_POSS = [4DuPoss] ; # 4th person dual possessor
LIST 4PL_POSS = [4PlPoss] ; # 4th person plural possessor

SET 4P_POSS = 4SG_POSS | 4DU_POSS | 4PL_POSS ; # 4th person possessor

#-------------#
# Noun Number #
#-------------#

LIST SG = [Sg] ; # singular noun
LIST DU = [Du] ; # dual noun
LIST PL = [Pl] ; # plural noun

################################
# morphological tags for verbs #
################################

LIST VERB = \(V\) ; # verb root
LIST EMO = \(EMO\) ; # emotional roots
LIST POS = \(POS\) ; # postural roots

LIST V_V = \(V→V\) ; # verb-elaborating postbase
LIST V_N = \(V→N\) ; # nominalizing postbase
LIST CMPDVBL = \(CmpdVbl\) ; # compound-verbal postbase
LIST EMON = \(EMO→N\) ; # emotional root to noun stem postbase
LIST EMOV = \(EMO→V\) ; # emotional root to verb stem postbase
LIST POSSTATIVE = \(POS→STATIVE\) ; # postural root to stative form postbase
LIST POSACTIVE = \(POS→ACTIVE\) ; # postural root to active form postbase
LIST POSQUANTQUAL = \(POS→QUANTQUAL\) ; # postural root to quantifier-qualifier construction

#------#
# Mood #
#------#

LIST IND = [Ind] ; # indicative mood for statements
LIST PTCP = [Ptcp] ; # participial mood
LIST PTCPOBL = [PtcpObl] ; # participial-oblique mood
LIST PREC = [Prec] ; # precessive mood 'before one V-ed or V-s'
LIST CONC = [Conc] ; # concessive mood 'even though one V-s'
LIST CNSQ1 = [Cnsq1] ; # consequential I mood 'when one V-ed'
LIST CNSQ2 = [Cnsq2] ; # consequential II mood 'while one was V-ing'
LIST COND = [Cond] ; # conditional mood 'if or when one Vs'
LIST CTMP = [Ctmp] ; # contemporative mood 'whenever one Vs'
LIST SBRD = [Sbrd] ; # intransitive subordinative mood 'V-ing'

LIST INTRG = [Intrg] ; # interrogative mood for questions
LIST OPT = [Opt] ; # optative mood for commands and suggestions

SET INDEPENDENT_MOOD = IND | INTRG | OPT | PTCP | PTCPOBL ; # independent mood (p. 83)
SET DEPENDENT_MOOD = PREC | CONC | CNSQ1 | CNSQ2 | COND | CTMP | SBRD ; # dependent or connective mood (p. 83)

SET MOOD = INDEPENDENT_MOOD | DEPENDENT_MOOD ;

LIST PRES = [Pres] ; #
LIST FUT = [Fut] ; #
LIST NEG = [Neg] ; #


#---------#
# Valency #
#---------#

LIST INTR = [Intr] ; # intransitive verb
LIST TRNS = [Trns] ; # transitive verb

SET ANY_VERB = INTR | TRNS ; # any verb (regardless of the root) will have one of these tags

#------------------------------------#
# intransitive person-number markers #
#------------------------------------#

LIST 1SG = [1Sg]; # 1st person singular subject
LIST 1DU = [1Du]; # 1st person dual subject
LIST 1PL = [1Pl]; # 1st person plural subject

LIST 2SG = [2Sg]; # 2nd person singular subject
LIST 2DU = [2Du]; # 2nd person dual subject
LIST 2PL = [2Pl]; # 2nd person plural subject

LIST 3SG = [3Sg]; # 3rd person singular subject
LIST 3DU = [3Du]; # 3rd person dual subject
LIST 3PL = [3Pl]; # 3rd person plural subject

LIST 4SG = [4Sg]; # 4th person singular subject
LIST 4DU = [4Du]; # 4th person dual subject
LIST 4PL = [4Pl]; # 4th person plural subject

SET 1P = 1SG | 1DU | 1PL ;
SET 2P = 2SG | 2DU | 3PL ;
SET 3P = 3SG | 3DU | 3PL ;
SET 4P = 4SG | 4DU | 4PL ;

SET SG_V = 1SG | 2SG | 3SG | 4SG ;
SET DU_V = 1DU | 2DU | 3DU | 4DU ;
SET PL_V = 1PL | 2PL | 3PL | 4PL ;

SET PERSON = 1P | 2P | 3P | 4P ;

#----------------------------------#
# transitive person-number markers #
#----------------------------------#

SET 3P_SUB = (3P PERSON) ;

#-------------------------#
# misc morphological tags #
#-------------------------#

LIST DEM = \(DEM\) \(DEM\] \[DEM\] ; # demonstrative
LIST DEMN = \(DEM→N\) ; # demonstrative to noun stem
LIST NUM = \(NUM\) ; # numeral
LIST NUMN = \(NUM→N\) ; # numeral to noun stem
LIST NUMV = \(NUM→V\) ; # numeral to verb stem
LIST PTCL = \(PTCL\) ; # particle
LIST PRO = \(PRO\) ; # pronoun
LIST WH = \(WH\) ; # question word
LIST QUANTQUAL = \(QUANTQUAL\) ; # for quantifier-qualifier constructions
LIST NQUANTQUAL = \(N→QUANTQUAL\) ; # noun stem to quantifier-qualifier postbase
LIST VQUANTQUAL = \(V→QUANTQUAL\) ; # verb stem to quantifier-qualifier postbase
LIST NXCLM = \(N→XCLM\) ; # noun stem to exclamation
LIST VXCLM = \(V→XCLM\) ; # verb stem to exclamation
LIST VOC = \(VOC\) ; # vocative
LIST VOLITIVEOFFEAR = [Volitive.Of.Fear] ; # for volitive of fear mood [Jacobson (2001) p.129]
LIST ENCLITIC = \= ; # enclitic

LIST AUG = \(Augmentive\) ; # augmentive postbase

SET DERIVATION = N_N | N_V | V_V | V_N | CMPDVBL | EMON | EMOV | POSSTATIVE | POSACTIVE | POSQUANTQUAL | NQUANTQUAL | VQUANTQUAL | AUG ;
LIST TO_HAVE_N_WRONG = (–leg \(N→N\) ~:\(ng\)u \(N→V\)) ; # The right analysis: –lgu [N.V]
LIST INTR_ONLY_BASE = "aane" "aange" "aghula" "aghulaqe" "aglagh"
                      "agniqe" "akuzi" "aleghquute" "alinge" "an'gigh"
					  "anuqligh" "aqii" "aqlaghate" "aqumga" "atghagh"
					  "esghaate" "esleqe" "ete" "geve" "gheve"
					  "igamsiqanagh" "igamsiqayug" "igatagh" "iglagtu" "iilqe"
					  "iiw" "iknaqe" "ilagagh" "iqalgu" "isekinagh"
					  "iyatagh" "kaleve" "kavite" "kepsugh" "kiyaghte"
					  "laalighte" "meghnugh" "meghtagh" "mekestaaghhaa" "meqsug"
					  "mughute" "naave" "naghaagh" "nanglii" "nekeve"
					  "nekevgha" "nenglagh" "nulugh" "pangeghte" "pinigh"
					  "piyaa" "piyug" "qaame" "qaprag" "qavagh"
					  "qavaghni" "qayugh" "qefliqe" "qiighw" "qimugsigh"
					  "qinuyug" "qiya" "qungyagh" "quya" "seghleghu"
					  "sughma" "sukangite" "sukate" "taake" "taaqe"
					  "taghtugh" "tagi" "taglagh" "takestaaghhaa" "teghtugh"
					  "tenge" "tuqu" "uglagh" "ugpegh" "ukig"
					  "umughqaa" "ungipaghagh" "uqengestagh" "uqigtu" "uteghnigh"
					  "yaave" "yuqeghte"; # verb bases that are known to be used as intransitive only

LIST TRNS_ONLY_BASE = "aate" "aghvig" "aghyuugh" "akite" "aleghqugh"
                      "alike" "amqeghte" "atuqe" "egte" "esghagh"
					  "ifkaghte" "igamsiqayugvike" "igleghte" "ini" "ivagh"
					  "kayusigh" "kenigh" "kitugh" "laalighfike" "liisimake"
					  "lli" "maligte" "muutighvike" "naafqe" "naalke"
					  "naallghute" "nalluke" "paagh" "payegh" "piniqe"
					  "pumsug" "qaamte" "qanigughte" "qungyake" "taghsagh"
					  "tagite" "taku" "taslugh" "tasluqe" "teghsagh"
					  "tugu" "tukfigh" "tuqlugh" "tuqute" "tuquuqagh"
					  "tuune" "ugpeqe" "ungipaate" "ungipaghaate" "utaqa"
					  "uutghute"; # verb bases that are known to be used as transitive only

# optional impersonal agent verb
# patientive
# agentive
# used in the dual

SECTION EXCEPTIONS ;
SELECT:WH_WORDS WH; # Select a WH reading if available
SELECT:WHICH_ONE_OF_PL PL IF (-1 ("naligh")); # Select a plural noun reading if the one preceding is "naligh" e.g. Naliita qikmima amqeghtaten? Which one of my dog"s" bit you?
SELECT:BECAUSE PTCL IF (0 ("qayughllak")) ; # Select the particle reading for qayughllak (because)
SELECT:INTR_ONLY INTR IF (0 INTR_ONLY_BASE) ; # Select an intransitive reading for verb bases that are known to be used as intransitive only.
SELECT:TRNS_ONLY_BASE TRNS IF (0 TRNS_ONLY_BASE) ; # Select a transitive reading for verb bases that are known to be used as transitive only.
REMOVE:NO_TO_HAVE_N_WRONG TO_HAVE_N_WRONG ; # –lgu [N.V] (to have V) should not be further analyzed as "–leg [N.N]~:(ng)u [N.V]" (the one who have N + to be N)
SELECT:WH_QUESTION WH IF (1C* INTRG); # Select a question word reading if there is an unambiguous interrogative verb following
REMOVE:NO_QUESTION INTRG IF (NEGATE @-1C QUESTION) ; # Remove an interrogative verb ([Intrg]) if there's no question mark at the end

SECTION MAPPING;

SECTION RULES ;
REMOVE:REL_INTR REL IF (0C* INTR BARRIER ABS) ; # If there's an unambiguous intransitive verb ([Intr]) cohort (meaning all possible analyses for a word in the window have an intransitive tag), remove a relative noun reading unless there is an unambiguous absolutive noun reading within the sentence (C3)
# REMOVE:NO_DOUBLE_V ANY_VERB IF (0C* ANY_VERB CBARRIER CLB) ; # Remove a verb reading if there's an umbiguous verb corhort in the sentence within a clause boundary. (C3)
REMOVE:NO_DOUBLE_INDEPENDENT_MOOD INDEPENDENT_MOOD IF (0C* INDEPENDENT_MOOD) ; # Remove a verb with an independent mood reading if there's an umbiguous verb corhort in the sentence within an independent mood.
# SELECT:ONE_INDEPENDENT_MOOD INDEPENDENT_MOOD IF (NEGATE 0* INDEPENDENT_MOOD) ;
SELECT:REL_ABS REL IF (1C ABS LINK 1* ANY_VERB) ; # Select a relative reading if it is immediately followed by an unambiguous abolutive reading followed by a verb later in the sentence.

SECTION AGREEMENT ;
# SELECT:REL_ABS_TRNS TRNS IF (0C* REL + ABS) ; # Pick a transitive verb reading if there are both relative and absolutive noun cases in the sentence unless there is another verb.
# If there is only one noun with a syntactic case (Abs/Rel), a verb has to agree with it in number any way
#SELECT:N_V_AGREEMENT_SG SG_V IF (0C* SYNTACTIC_CASE + SG BARRIER SYNTACTIC_CASE) ;
#SELECT:N_V_AGREEMENT_DU DU_V IF (0C* SYNTACTIC_CASE + DU BARRIER SYNTACTIC_CASE) ;
#SELECT:N_V_AGREEMENT_PL PL_V IF (0C* SYNTACTIC_CASE + PL BARRIER SYNTACTIC_CASE) ;

# Unless there is another absolutive noun in the sentence, an absolutive noun has to agree in number with the subject of an intransitive verb.
SELECT:ABS_INTR_AGREEMENT_SG ([Abs] [Sg]) IF (0C* ([Intr] [3Sg]) BARRIER ABS);
SELECT:ABS_INTR_AGREEMENT_DU ([Abs] [Du]) IF (0C* ([Intr] [3Du]) BARRIER ABS);
SELECT:ABS_INTR_AGREEMENT_PL ([Abs] [Pl]) IF (0C* ([Intr] [3Pl]) BARRIER ABS);

SELECT:ABS_TRNS_AGREEMENT_SG ([Abs] [Pl]) IF (0C* ([Trns] PERSON [3Pl]) BARRIER SYNTACTIC_CASE) ;
# SELECT (N REL SG) IF (1C* (V MOOD TRNS 3SG PERSON)) ;

SECTION HEURISTICS ;
SELECT:YES_QUESTION INTRG IF (@-1C QUESTION) ; # Select an interrogative verb ([Intrg]) if there is a question mark at the end
REMOVE:REMOVE_DEM DEM; # Remove a demonstrative reading if possible
REMOVE:NO_4P_POSS 4P_POSS ; # Remove 4th person inflection analyses as long as there are other readings
REMOVE:NO_TRIPLE_DERIVATION (<DER>2>); # Remove analyses with three derivational morphemes (e.g. N->N ?* N->V ?* V->N) as long as there are other readings (to select the shortest analysis)
REMOVE:NO_DOUBLE_DERIVATION (<DER>1>); # Remove analyses with two derivational morphemes
REMOVE:NO_DERIVATION DERIVATION ; # Remove analyses with any derivational morphemes as long as there are other readings (to select the shortest analysis)
REMOVE:NO_VERBALIZING N_V; # My observation is that if possible, elaborating postbases are preferred
REMOVE:NO_NOMINALIZING V_N; # My observation is that if possible, elaborating postbases are preferred
REMOVE:NO_ENCLITIC ENCLITIC ; # Remove analyses with an enclitic reading as long as there is another reading
# select the shortest analysis
